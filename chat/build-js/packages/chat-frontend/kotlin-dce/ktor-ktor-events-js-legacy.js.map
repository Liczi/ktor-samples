{"version":3,"file":"ktor-ktor-events-js-legacy.js","sources":["../../../../../ktor-shared/ktor-events/common/src/io/ktor/events/Events.kt"],"sourcesContent":["/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.events\n\nimport io.ktor.util.*\nimport io.ktor.util.collections.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.internal.*\n\n@OptIn(InternalAPI::class)\npublic class Events {\n    @OptIn(InternalCoroutinesApi::class)\n    private val handlers = CopyOnWriteHashMap<EventDefinition<*>, LockFreeLinkedListHead>()\n\n    /**\n     * Subscribe [handler] to an event specified by [definition]\n     */\n    public fun <T> subscribe(definition: EventDefinition<T>, handler: EventHandler<T>): DisposableHandle {\n        val registration = HandlerRegistration(handler)\n        @OptIn(InternalCoroutinesApi::class)\n        handlers.computeIfAbsent(definition) { LockFreeLinkedListHead() }.addLast(registration)\n        return registration\n    }\n\n    /**\n     * Unsubscribe [handler] from an event specified by [definition]\n     */\n    public fun <T> unsubscribe(definition: EventDefinition<T>, handler: EventHandler<T>) {\n        @OptIn(InternalCoroutinesApi::class)\n        handlers[definition]?.forEach<HandlerRegistration> {\n            if (it.handler == handler) it.remove()\n        }\n    }\n\n    /**\n     * Raises the event specified by [definition] with the [value] and calls all handlers.\n     *\n     * Handlers are called in order of subscriptions.\n     * If some handler throws an exception, all remaining handlers will still run. The exception will eventually be re-thrown.\n     */\n    public fun <T> raise(definition: EventDefinition<T>, value: T) {\n        var exception: Throwable? = null\n        handlers[definition]?.forEach<HandlerRegistration> { registration ->\n            try {\n                @Suppress(\"UNCHECKED_CAST\")\n                (registration.handler as EventHandler<T>)(value)\n            } catch (e: Throwable) {\n                exception?.addSuppressed(e) ?: run { exception = e }\n            }\n        }\n        exception?.let { throw it }\n    }\n\n    @OptIn(InternalCoroutinesApi::class)\n    private class HandlerRegistration(val handler: EventHandler<*>) : LockFreeLinkedListNode(), DisposableHandle {\n        override fun dispose() {\n            remove()\n        }\n    }\n}\n\n/**\n * Specifies signature for the event handler\n */\npublic typealias EventHandler<T> = (T) -> Unit\n\n// TODO: make two things: definition that is kept private to subsystem, and declaration which is public.\n// Invoke only by definition, subscribe by declaration\n\n/**\n * Definition of an event.\n * Event is used as a key so both [hashCode] and [equals] need to be implemented properly.\n * Inheriting of this class is an experimental feature.\n * Instantiate directly if inheritance not necessary.\n *\n * @param T specifies what is a type of a value passed to the event\n */\npublic open class EventDefinition<T>\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAWA,kB;IAEI,kBACuB,wB;G;EAQkB,qC;IAAE,2B;G;uCAN3C,+B;QAII,mBAAmB,0BAAnB,CAAmB,OAAnB,C;IAEA,uCAAS,qCAA4B,gBAA6B,c;WAClE,Y;G;EAQmD,oD;IAAA,qB;UAC/C,MAAI,aAAG,eAAH,C;QAA0B,W;aAClC,I;K;G;yCAPJ,+B;QAKI,I;QAAA,wD;;;;UAAmD,uC;;;;G;EAaA,4E;IAAA,+B;gBAG7B,M;;QAAb,CAAa,QAAb,IAAa,GAAA,YAAb,QAAa,MAAb,UAAA,oC;;YACH,2B;cACE,0F;4BAAmC,C;YAAE,+B;;;gBAJzC,C;;aAMJ,I;K;G;mCAfJ,6B;QAQI,I,EAAA,M;QADA,gBACA,IADA,C;;;;YACmD,8C;;;;;SAQlC,oB;;;G;;IAIa,yB;;;;IAG9B,I;;;;;;;;;;;;;;;"}