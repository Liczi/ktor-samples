{"version":3,"file":"ktor-ktor-serialization-js-legacy.js","sources":["../../../../../ktor-shared/ktor-serialization/common/src/ContentConvertException.kt","../../../../../ktor-shared/ktor-serialization/common/src/ContentConverter.kt"],"sourcesContent":["/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.serialization\n\nimport io.ktor.websocket.*\n\npublic open class ContentConvertException(\n    message: String,\n    cause: Throwable? = null\n) : Exception(message, cause)\n\npublic class JsonConvertException(\n    message: String,\n    cause: Throwable? = null\n) : ContentConvertException(message, cause)\n\npublic open class WebsocketContentConvertException(\n    message: String,\n    cause: Throwable? = null\n) : ContentConvertException(message, cause)\n\npublic class WebsocketConverterNotFoundException(\n    message: String,\n    cause: Throwable? = null\n) : WebsocketContentConvertException(message, cause)\n\npublic class WebsocketDeserializeException(\n    message: String,\n    cause: Throwable? = null,\n    public val frame: Frame\n) : WebsocketContentConvertException(message, cause)\n","/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.serialization\n\nimport io.ktor.http.*\nimport io.ktor.http.content.*\nimport io.ktor.util.pipeline.*\nimport io.ktor.util.reflect.*\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\nimport kotlin.reflect.*\n\n/**\n * A custom content converter that could be registered in [ContentNegotiation] plugin for any particular content type\n * Could provide bi-directional conversion implementation.\n * One of the most typical examples of content converter is a JSON content converter that provides both\n * serialization and deserialization\n */\npublic interface ContentConverter {\n\n    /**\n     * Serializes a [value] to the specified [contentType] to a [OutgoingContent].\n     * This function could ignore value if it is not suitable for conversion and return `null` so in this case\n     * other registered converters could be tried or this function could be invoked with other content types\n     * it the converted has been registered multiple times with different content types\n     *\n     * @param charset response charset\n     * @param typeInfo response body typeInfo\n     * @param contentType to which this data converter has been registered and that matches the client's [Accept] header\n     * @param value to be converted\n     *\n     * @return a converted [OutgoingContent] value, or null if [value] isn't suitable for this converter\n     */\n    public suspend fun serialize(\n        contentType: ContentType,\n        charset: Charset,\n        typeInfo: TypeInfo,\n        value: Any\n    ): OutgoingContent?\n\n    /**\n     * Deserializes [content] to the value of type [typeInfo]\n     *\n     * @return a converted value (deserialized) or `null` if the context's subject is not suitable for this converter\n     */\n    public suspend fun deserialize(charset: Charset, typeInfo: TypeInfo, content: ByteReadChannel): Any?\n}\n\n/**\n * Detect suitable charset for an application call by `Accept` header or fallback to [defaultCharset]\n */\npublic fun Headers.suitableCharset(defaultCharset: Charset = Charsets.UTF_8): Charset =\n    suitableCharsetOrNull(defaultCharset) ?: defaultCharset\n\n/**\n * Detect suitable charset for an application call by `Accept` header or fallback to null\n */\npublic fun Headers.suitableCharsetOrNull(defaultCharset: Charset = Charsets.UTF_8): Charset? {\n    for ((charset, _) in parseAndSortHeader(get(HttpHeaders.AcceptCharset))) when {\n        charset == \"*\" -> return defaultCharset\n        Charset.isSupported(charset) -> return Charset.forName(charset)\n    }\n    return null\n}\n\n/**\n * Configuration for client and server `ContentNegotiation` plugin\n */\npublic interface Configuration {\n\n    public fun <T : ContentConverter> register(\n        contentType: ContentType,\n        converter: T,\n        configuration: T.() -> Unit = {}\n    )\n}\n"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;EAQyC,iD;IAErC,qB;MAAA,QAAoB,I;IACpB,qBAAU,OAAV,EAAmB,KAAnB,C;;G;;;;MAO8C,Y;IAE9C,uB;IAAA,SAAoB,qC;;;;;;IAGwB,2D;IAE5C,iD;;EACA,8CAAiC,wH;;;;;IAEK,kB;IAEtC,2C;;EAEA,kDADA,UACA,8F;;;;;;;ECmBJ,0D;IAGmC,8B;MAAA,iBAA0B,iBAAS,M;IAClE,Q;IAAA,OAAA,yCAAsB,gBAAtB,yBAAyC,E;;MAE7C,wB;MAGyC,iC;MAAA,oBAA0B,GAA1B,E;QAChB,qB;WAAA,IAAA,iBAAmB,oBAAI,SAAvB,C;QAArB,OAAqB,iBAArB,yB;;WAAM,I;G;;;;;;;;;;;;"}